---
title: Collecting Test Coverage from Playwright Runs
date: 2025/05/09
---

Test coverage collection is a good tool to evaluate how much of your code is being tested. It can help you identify untested parts of your codebase and improve your test suite.
I recently had to implement test coverage collection for a Playwright test suite.

I searched for a bit online, and got some pointers through blog articles about how I could achieve that.

The basic idea is to use [custom Playwright fixtures](https://playwright.dev/docs/test-fixtures#creating-a-fixture), by extending the built-in `test` utility, to collect coverage data created using the [`vite-plugin-istanbul`](https://www.npmjs.com/package/vite-plugin-istanbul) package. If your project doesn't use [Vite](https://vite.dev/), there is probably another option for you to collect the coverage data, all that is needed for the rest is that the coverage data gets collected into `window.__coverage__`.

### Setting Vite up

First of all, we need to install the `vite-plugin-istanbul` package that will allow us to collect coverage data in the browser.

```bash
pnpm install -D vite-plugin-istanbul
```

In our `vite.config.ts`, let's setup the plugin:

```ts
import { defineConfig } from "vite";
import istanbul from "vite-plugin-istanbul";

const config = defineConfig({
  plugins: [
    // ...
    ...(process.env.ISTANBUL_COVERAGE
      ? [
          istanbul({
            include: "src/*",
            exclude: ["node_modules", "test/"],
            extension: [".js", ".jsx", ".ts", ".tsx"],
            requireEnv: false,
            checkProd: false,
            forceBuildInstrument: true,
          }),
        ]
      : []),
  ],
  build: {
    // ...
    sourcemap:
      mode === "production" || !!process.env.ISTANBUL_COVERAGE,
  },
  // ...
});

export default config;
```

This will depend on the project, here we're only enabling the plugin if the environment variable `process.env.ISTANBUL_COVERAGE` is enabled. This way, we're only collecting data exactly when we want (when Playwright starts the server). We're also adding the sourcemaps to the build if this variable is set, so that the coverage can map to the actual source code, and not the bundled code.

Let's also setup the environment variable in the Playwright config file (`playwright.config.ts`):

```ts {7}
import { defineConfig } from "@playwright/test";

export default defineConfig({
  // ...
  webServer: {
    // ...
    env: { ISTANBUL_COVERAGE: "1" },
  },
  // ...
});
```

Now that we have the setup, we can implement the coverage collection itself.

### Creating the fixture

In a utility file next to the tests, we're going to expose our own `test` function, that will need to be used in every test file instead of the default import from `@playwright/test`.

```ts
import { test as baseTest } from "@playwright/test";

export const test = baseTest.extend({});
export const expect = test.expect;
```

We also have to export the `expect` utility created from our custom `test`, and use it in every test as well.

Inside the `extend` method, we can create our own fixtures (that will be available inside the test functions) or override existing ones. To implement test coverage, we need to extend the existing `context` fixture, in order to run code before the context is used in the tests (to add the collecting code) and after (to save the coverage data to a directory).

```ts {4}
// ...

export const test = baseTest.extend({
  context: async ({ browser }, use) => {},
});

// ...
```

### Adding the coverage code

First, let's use the `mkdir` Node function to create the directory that will hold our coverage data.

```ts {7,11-13}
import * as fs from "fs";
import * as path from "path";
import { fileURLToPath } from "url";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
// coverage directory path, relative to this file
const istanbulCLIOutput = path.join(__dirname, "../.nyc_output");

export const test = baseTest.extend({
  context: async ({ browser }, use) => {
    await fs.promises.mkdir(istanbulCLIOutput, {
      recursive: true,
    });
  },
});
```

We're setting the `recursive` option so that the function doesn't throw if the directory already exists.

Next, we're going to create our own `BrowserContext` instance, in order to have control over how it behaves.

```ts {4}
export const test = baseTest.extend({
  context: async ({ browser }, use) => {
    // ...
    const context = await browser.newContext();
  },
});
```

Then, we're going to expose a function on the `window` object in every page of our context, called `collectIstanbulCoverage`. This function takes the coverage data generated by [Istanbul](https://istanbul.js.org/) as a JSON string and creates a file with a random name containing the data, inside the directory we just created.

```ts
export const test = baseTest.extend({
  context: async ({ browser }, use) => {
    // ...
    await context.exposeFunction(
      "collectIstanbulCoverage",
      (coverageJSON: string) => {
        if (!coverageJSON) return;
        const filePath = path.join(
          istanbulCLIOutput,
          `playwright_coverage_${generateUUID()}.json`,
        );
        fs.writeFileSync(filePath, coverageJSON);
      },
    );
  },
});
```

We're then going to tell Playwright to run a function when initializing every new page in our context, using `context.addInitScript`. This function will add an event listener to `window`, on the "beforeunload" event
